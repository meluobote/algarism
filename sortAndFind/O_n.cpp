/*
 * 描述: 桶排序、计数排序、基数排序
 *  1） 桶排序： 桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，无法将数据全部加载到内存中。
 *比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，
 * 没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？ * 现在我来讲一下，如何借助桶排序的处理思想来解决这个问题。
 * 我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。
 * 我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001
 * 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件， * 并且按照金额范围的大小顺序编号命名（00，01，02…99）。
 * 理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，
 * 每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序（非稳定排序）
 *      说明：扫描一次10GB数据时，可以选择按行扫描，同时打开100个文件对象，每次直接写入磁盘，不使用缓存。
 *      也可以使用缓存但不要太大，以防内存不够
 *      例子二：考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。
 *  据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。
 *  我们只需要依次扫描每个桶， *  将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，
 *  所以时间复杂度是 O(n)。
 *  2） 计数排序： 是稳定的排序算法， 不是原地排序
 *      计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，
 *      计数排序只能给非负整数排序， *      如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数
 *  3) 基数排序：
 * 作者：meluobote
 * 日期: 2020/3/27
 */
#include <vector>
#include <iostream>
#include <math.h>
using namespace std;
void print(vector<int>& v){
    for(auto e:v){
        cout<<e<<" ";
    }
    cout<<endl;
}
//计数排序
void countSort(vector<int>& v){
    vector<int> val(100);
    for(auto e: v){
        val[e]++;
    }
    for(int i=1;i<val.size();i++){
        val[i]+=val[i-1];
    }
    vector<int> v_cp(v);
    for(int i=v_cp.size()-1;i>=0;i--){
        v[val[v_cp[i]]-1]=v_cp[i];
        val[v_cp[i]]--;
    }
}

/*
 * 基数排序
 *  params:  ws  代表最大的数是几位的， 如，123 -》 3
 */
void regdexSort(vector<int>& v, int ws){


    for(int i=0;i<ws;i++){
        //取v的某个位， 如个位、十位、百位
        vector<int> v_cp(v);
        vector<int> wv(v.size(),0);
        vector<int> val(10, 0);
        for(int j=0;j<v.size();j++){
            wv[j]=v[j]/static_cast<int>(pow(10,i))%10;
        }

        for(int j=0;j<wv.size();j++){
            val[wv[j]]++;
        }
        for(int j=1;j<val.size();j++){
            val[j]+=val[j-1];
        }

        for(int j=v.size()-1;j>=0;j--){
            v[val[wv[j]]-1]=v_cp[j];
            val[wv[j]]--;
        }
    }
}


int main() {
//    vector<int> v{3,2,1,5,6,4,5,2};
//    countSort(v);

    vector<int> v{12, 333, 562, 915, 263, 9, 219};
    regdexSort(v, 3);
    print(v);

}